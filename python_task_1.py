# -*- coding: utf-8 -*-
"""Copy of Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LD2woYeHwO7CNMTYws7j_v-tQhsGyA1O
"""

import pandas as pd
import numpy as np



#question1

def generate_car_matrix(dataset_path):
    # Read the CSV file into a DataFrame
    df = pd.read_csv(dataset_path)

    # Pivot the DataFrame using id_1, id_2, and car columns
    matrix_df = df.pivot(index='id_1', columns='id_2', values='car')

    # Fill NaN values with 0 and replace diagonal values with 0
    matrix_df = matrix_df.fillna(0)
    matrix_df.values[[range(len(matrix_df))]*2] = 0

    return matrix_df

result_matrix = generate_car_matrix('dataset-1.csv')
print(result_matrix)


#question2

def get_type_count(df):

    conditions = [
        (df['car'] <= 15),
        (df['car'] > 15) & (df['car'] <= 25),
        (df['car'] > 25)
    ]

    choices = ['low', 'medium', 'high']
    df['car_type'] = pd.Series(np.select(conditions, choices, default='Unknown'),dtype='category')

    # Calculate the count of occurrences for each 'car_type' category
    type_count = df['car_type'].value_counts().to_dict()

    # Sort the dictionary alphabetically based on keys
    type_count = dict(sorted(type_count.items()))

    return type_count

df = pd.read_csv('dataset-1.csv')

result = get_type_count(df)
print(result)

#question3

def get_bus_indexes(dfs):
    # Calculate the mean value of the 'bus' column
    bus_mean = dfs['bus'].mean()

    # Identify indices where 'bus' values are greater than twice the mean
    bus_indexes = dfs[dfs['bus'] > 2 * bus_mean].index.tolist()

    # Sort the indices in ascending order
    bus_indexes.sort()

    return bus_indexes
dfs = pd.read_csv('dataset-1.csv')

result = get_bus_indexes(dfs)
print(result)

#question4

def filter_routes(d):
    # Group by 'route' and calculate the average of 'truck' column for each route
    route_avg_truck = d.groupby('route')['truck'].mean()

    # Filter routes where the average of 'truck' column is greater than 7
    selected_routes = route_avg_truck[route_avg_truck > 7].index.tolist()

    # Sort the list of selected routes
    selected_routes.sort()

    return selected_routes

d = pd.read_csv('dataset-1.csv')

result = filter_routes(d)
print(result)

#question5

def multiply_matrix(input_matrix):
    # Create a copy of the input matrix to avoid modifying the original
    modified_matrix = input_matrix.copy()

    # Apply the specified logic to each value in the matrix
    modified_matrix = modified_matrix.applymap(lambda x: x * 0.75 if x > 20 else x * 1.25)

    # Round the values to 1 decimal place
    modified_matrix = modified_matrix.round(1)

    return modified_matrix

result_matrix = generate_car_matrix('dataset-1.csv')

# Call the multiply_matrix function with the result_matrix
modified_result = multiply_matrix(result_matrix)

# Print the modified DataFrame
print(modified_result)


#question6

def check_timestamps(t):
    # Combine 'startDay' and 'startTime' columns into a single datetime column 'start_timestamp'
    t['start_timestamp'] = pd.to_datetime(t['startDay'] + ' ' + t['startTime'])

    # Combine 'endDay' and 'endTime' columns into a single datetime column 'end_timestamp'
    t['end_timestamp'] = pd.to_datetime(t['endDay'] + ' ' + t['endTime'])

    # Check if timestamps cover a full 24-hour period and span all 7 days of the week
    t['valid_timestamp'] = (t['end_timestamp'] - t['start_timestamp'] == pd.Timedelta(days=1)) & \
                            (t['start_timestamp'].dt.hour == 0) & \
                            (t['start_timestamp'].dt.minute == 0) & \
                            (t['start_timestamp'].dt.second == 0) & \
                            (t['end_timestamp'].dt.hour == 23) & \
                            (t['end_timestamp'].dt.minute == 59) & \
                            (t['end_timestamp'].dt.second == 59) & \
                            (t['start_timestamp'].dt.dayofweek == 0) & \
                            (t['end_timestamp'].dt.dayofweek == 6)

    # Create a multi-index series with (id, id_2) as the index
    result_series = df.set_index(['id', 'id_2'])['valid_timestamp']

    return result_series


df = pd.read_csv('dataset-2.csv')

# Call the check_timestamps function with the dataset
result_series = check_timestamps(df)

# Print the boolean series with multi-index
print(result_series)